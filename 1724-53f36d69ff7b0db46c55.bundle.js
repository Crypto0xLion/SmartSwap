"use strict";(self.webpackChunksmardex_web=self.webpackChunksmardex_web||[]).push([[1724],{41724:function(e,a,s){s.d(a,{y:function(){return Me}});var t=s(36874),n=s(38350),r=s(4434),i=s(86386),o=s(81202),c=s(45962),d=s(48635),u=s(78712),l=s(92333),p=s(54291),g=s(78552),m=s(64382),f=s(68802),h=s(36461),k=s(35133),w=s(26715),y=s(18644),v=s(24357),T=s(63366),I=s(33277),b=s(34166),S=s(29430),P=s(93844),$=s(7833),C=s(84328),N=s(18700),B=s(8822),A=s(92819),F=s(96711),E=s(29522),D=s(8636),x=s(16308),V=s(4255),R=s(20036),O=s(61158),U=s(47566),M=s(61016);const Q=(0,t.NY)()({state:function(){const{chains:e,publicClient:a}=R.Z.configureChains(O.D,[(0,r.G)({apiKey:"6IrrAZ2ME1DaAK_QG7t8a-7Va-WWGQQT"}),(0,i.$)({apiKey:"9f3f8327e3944434a7a53856d7714675"}),(0,M._)(),(0,U.n)({apiKey:"143bdef4ea35b3e9d0e38689a258ccda84c3db6ba44526eb3ca221e2cbbbcf2f"}),(0,o.I)()],{batch:{multicall:{batchSize:4096}}}),s="82a614d47945ceed415b40b277797f4a",t=(0,c.a3)([{groupName:"Recommended",wallets:[(0,d.U)({chains:e}),(0,u.P)({projectId:s,chains:e}),(0,l.D)({chains:e,appName:"Sentia"}),(0,p.D)({projectId:s,chains:e}),(0,g.u)({projectId:s,chains:e}),(0,m.Z)({projectId:s,chains:e}),(0,f.M)({chains:e}),(0,h.f)({chains:e}),(0,k.N)({chains:e}),(0,w.P)({projectId:s,chains:e}),(0,y.u)({projectId:s,chains:e}),(0,v.C)({chains:e}),(0,T.c)({projectId:s,chains:e}),(0,I._)({projectId:s,chains:e}),(0,b.b)({chains:e}),(0,S.R)({chains:e}),(0,P.l)({chains:e}),(0,$.k)({chains:e}),(0,C.p)({projectId:s,chains:e}),(0,N.U)({chains:e}),(0,B.B)({projectId:s,chains:e}),(0,A.b)({projectId:s,chains:e}),(0,F.u)({projectId:s,chains:e}),(0,E.J)({projectId:s,chains:e}),(0,D.o)({chains:e}),(0,x.S)({chains:e}),(0,V.J)({projectId:s,chains:e})]}]);return{chains:e,wagmiConfig:(0,n._g)({autoConnect:!0,connectors:t,publicClient:a}),chain:O.D[0]}}(),reducers:{setChain(e,a){return{...e,chain:a}}},effects(e){return{}}});var L=s(58903),j=s(24889);var q=s(88827),G=s(83871),_=s(78317);const W=(0,t.NY)()({state:{totalSupply:0n,circulatingSupply:0n,burnedSupply:0n},reducers:{setGlobalTvl(e,a){return{...e,globalTvl:a}},setSDEXPrice(e,a){return{...e,sdexPrice:a}},setVolumesMetric(e,a){return{...e,volumes:a}},setTVLsMetric(e,a){return{...e,tvls:a}},setSupply(e,a){return{...e,...a}}},effects(e){return{async getGlobalTVL(a,s){const{chains:t}=s.network,n=[];t.forEach((e=>{n.push(G.V.fetch(e.sdId,"metrics/tvl.json").catch((()=>({total_usd:0,staking_usd:0,pairs_usd:0}))))}));const r=await Promise.all(n),i=r.reduce(((e,a)=>e+a.total_usd),0);r&&e.metrics.setGlobalTvl(i)},async getSDEXPrice(a,s){const t=await G.V.fetchMM("sdex-price").catch((()=>null));t&&e.metrics.setSDEXPrice(t)},async getVolumesMetric(a,s){const t=await fetch("https://api.llama.fi/summary/dexs/smardex?excludeTotalDataChartBreakdown=true&dataType=dailyVolume").then((e=>e.json()));t&&e.metrics.setVolumesMetric(t)},async getTVLsMetric(a,s){const t=await fetch("https://api.llama.fi/protocol/smardex").then((e=>e.json()));t&&e.metrics.setTVLsMetric(t)},async getSupply(a,s){const{chains:t}=s.network,n=[];t.forEach((e=>{const a=(0,j.uN)({address:e.SmardexToken.address,abi:q.x,chainId:e.id});n.push(Promise.all([a.read.balanceOf([_.EV]),a.read.balanceOf([e.FarmingRange.address]),a.read.balanceOf([e.RewardManager.address]),e.FarmingRangeV1?a.read.balanceOf([e.FarmingRangeV1.address]):Promise.resolve(0n),e.RewardManagerV1?a.read.balanceOf([e.RewardManagerV1.address]):Promise.resolve(0n)]))}));const r=await Promise.all(n),i=r.map((e=>{let[a]=e;return a})).reduce(((e,a)=>e-a),(0,L.f)("10000000000")),o=r.map((e=>e.reduce(((e,a)=>e+a),0n))).reduce(((e,a)=>e-a),(0,L.f)("10000000000")),c=r.map((e=>{let[a]=e;return a})).reduce(((e,a)=>e+a),0n);e.metrics.setSupply({totalSupply:i,circulatingSupply:o,burnedSupply:c})}}}});var H=s(97451),z=s(60263),Y=s(14646),K=s(61673),J=s(27296),X=s(35691),Z=s(51228);const ee=(0,t.NY)()({state:(0,Y.D)(),reducers:{setApiTokens(e,a){const{chain:s,tokens:t}=a,{sdId:n}=s;return{...e,tokens:{...e.tokens,[n]:[...e.tokens[n],...t]}}},prependToken(e,a){const{chain:s,token:t}=a,{sdId:n}=s;return{...e,tokens:{...e.tokens,[n]:[t,...e.tokens[n]]}}},setSources(e,a){return{...e,sources:a}}},effects(e){return{async getApiTokens(a,s){const{token:t,network:n}=s,{chain:r}=n;if(!r)return;const{sdId:i,cgId:o}=r,c=t.tokens[i].filter((e=>e.approved||e.source)),d=J[i];if(c.length>d.length)return void console.debug(`[TOKEN:${i}] call getApiTokens from cache`);const u=(await G.V.fetchCGTokens(o).catch((()=>{})))?.tokens;if(u){const a=u.filter((e=>e.address!==_.I1&&e.name&&e.symbol&&!e.symbol?.includes("_")&&!e.symbol?.includes("-")&&!c.find((a=>a.address===e.address)))).map((e=>{const a=e.address?.toLowerCase();return{name:e.name||"",symbol:e.symbol||"",decimals:e.decimals||_.p8,address:a||_.je,icon:e.logoURI||Z.x.getNotFoundIcon(),approved:!1,source:"CoinGecko",price:0n,balance:0n,allowance:0n}}));e.token.setApiTokens({chain:r,tokens:a})}},async getTokens(a,s){const t=(0,j.D0)().address,{offset:n,searchAddress:r}=a,{network:i,token:o}=s,{chain:c}=i;if(!c)return null;const{sdId:d}=c,u=o.tokens[d],l=u.find((e=>e.referral));if(!l)return null;const p=new RegExp(r||"","i"),g=u.filter((e=>!e.source||o?.sources[e.source])).filter((e=>p.test(e.symbol)||p.test(e.name)||p.test(e.address))).slice(n,n+Y.m);if(!g.length&&r&&(0,H.U)(r)){const a=r.toLowerCase(),s=(0,j.uN)({address:a,abi:j.em,chainId:c.id}),[t,n,i]=await Promise.all([s.read.name().catch((()=>null)),s.read.decimals().catch((()=>null)),s.read.symbol().catch((()=>null))]);if(t&&i){const s={name:t,symbol:i,decimals:n||_.p8,address:a,icon:Z.x.getNotFoundIcon(),hasNative:!1,approved:!1,price:0n,balance:0n,allowance:0n};e.token.save({chain:c,token:s}),e.token.prependToken({chain:c,token:s}),g.push(s)}}const m=g.find((e=>!!e.wrap)),f=[],h=[],k=[];g.forEach((a=>{const{address:s,source:n}=e.token.prepareToken(a),r=(0,j.uN)({address:s,abi:j.em,chainId:c.id});t?h.push(Promise.all([r.read.balanceOf([t]).catch((()=>null)),r.read.allowance([t,c.SmardexRouter.address]).catch((()=>null))])):h.push(Promise.resolve([null,null])),n?(k.push(Promise.resolve(null)),f.push(s)):k.push(e.token.getPrice(a))}));const[w,y,v,T]=await Promise.all([Promise.all(h),Promise.all(k),f.length?G.V.fetchCGPrices(c.cgId,f):Promise.resolve(void 0),m&&t?(0,j.uV)({chainId:c.id})?.getBalance({address:t}):Promise.resolve(void 0)]);return g.map(((e,a)=>{const{address:s,wrap:n}=e;let r;if(s===l.address)r=_.CI;else if(y[a])r=y[a]||0n;else{const e=v?.[s]?.usd?.toFixed(_.p8);r=e?(0,L.f)(e.toString()):0n}const i={balance:0n,allowance:0n};if(t)if(n)i.balance=T||0n,i.allowance=_.iD;else if(w[a]){const[e,s]=w[a];i.balance=e||0n,i.allowance=s||0n}return{...e,...i,price:r}}))},async getToken(a,s){return(await e.token.getTokens({offset:0,searchAddress:a}))?.filter((e=>!e.wrap))?.[0]||void 0},getTokenFromState(e,a){const{chain:s}=a.network;if(s)return a.token.tokens[s.sdId].find((a=>a.address===e.toLowerCase()))},getNativeFromState(e,a){const{chain:s}=a.network;if(s)return a.token.tokens[s.sdId].find((e=>!!e.wrap))},getSDEXFromState(e,a){const{chain:s}=a.network;if(s)return a.token.tokens[s.sdId].find((e=>"SMART"===e.symbol))},async getBalance(e,a){const s=(0,j.D0)().address,{chain:t}=a.network,{address:n,wrap:r}=e;if(!s||!t)return null;if(r){return await((0,j.uV)({chainId:t.id})?.getBalance({address:s}))||0n}return(0,j.uN)({address:n,abi:j.em,chainId:t.id}).read.balanceOf([s]).catch((()=>null))},async getAllowance(e,a){const s=(0,j.D0)().address,{chain:t}=a.network,{spender:n,token:r}=e,{address:i,wrap:o}=r;if(!s||!t)return null;if(o)return _.iD;return(0,j.uN)({address:i,abi:j.em,chainId:t.id}).read.allowance([s,n]).catch((()=>null))},async getPrice(a,s){const{address:t,source:n}=e.token.prepareToken("token"in a?a.token:a),{token:r,network:i}=s,o="chain"in a?a.chain:i.chain;if(!o)return 0n;const{sdId:c}=o,d=r.tokens[c],u=d.find((e=>e.referral)),l=d.find((e=>e.hasNative)),p=d.find((e=>e.address===o.SmardexToken.address));if(!u||!l||!p)return 0n;if(t===u.address)return _.CI;if(!n){const e=await G.V.fetch(c,`prices/${t}.json`).catch((()=>null));if(e){const{usd:a,sdex:s,weth:t}=e;if(a)return(0,L.f)(a.toFixed(_.p8));const n=G.V.fetch(c,`prices/${p.address}.json`).catch((()=>null));if(s){const e=(await n)?.usd||0,a=(0,L.f)(s.toFixed(_.p8))*(0,L.f)(e.toFixed(_.p8));return(0,L.f)((0,z.b)(a,36))}if(t){const e=await G.V.fetch(c,`prices/${l.address}.json`).catch((()=>null));let a=0n;if(e?.sdex){const s=(await n)?.usd||0,t=(0,L.f)(e.sdex.toFixed(_.p8))*(0,L.f)(s.toFixed(_.p8));a=(0,L.f)((0,z.b)(t,36))}else a=(0,L.f)((e?.usd||0).toFixed(_.p8));return(0,L.f)((0,z.b)((0,L.f)(t.toFixed(_.p8))*a,36))}}}const g=await G.V.fetchCGPrices(o.cgId,[t]),m=g?.[t]?.usd?.toFixed(_.p8);return m?(0,L.f)(m):0n},sort(a,s){const t=e.token.prepareTokens(a);return BigInt(t[0].address)<BigInt(t[1].address)?t:t.reverse()},sortAddresses(e,a){return BigInt(e[0])<BigInt(e[1])?e:e.reverse()},save(e,a){const{chain:s,token:t}=e,{sdId:n}=s,{address:r,name:i,symbol:o,decimals:c,icon:d}=t,u=`tokens-${n}`,l=K.U.getItem(u),p={name:i,symbol:o,decimals:c,address:r,icon:d};if(l){const e=JSON.parse(l);e.find((e=>e.address===p.address))||(e.push(p),K.U.setItem(u,JSON.stringify(e)))}else K.U.setItem(u,JSON.stringify([p]))},saveSources(a,s){e.token.setSources(a),K.U.setItem("token-sources",JSON.stringify(a))},async approve(a,s){const{token:t,spender:n,amount:r,onSuccess:i,onError:o}=a,{name:c,symbol:d,address:u}=t,{chain:l}=s.network;if(!l)return;const p=`approve-token-${d}`;await e.transactionQueue.push({name:`Approve ${c} token`,call:{address:u,abi:X.Z,functionName:"approve",args:[n,r]},notifications:{info:{id:p,title:`Approving ${c} token...`,content:"Check your wallet",duration:1/0},success:{id:p,title:`Approve of ${c} succeeded`},error:{id:p,title:`Approve of ${c} failed`}},onSuccess:i,onError:o})},prepareToken(e,a){return{...e,address:e.wrap?.address||e.address}},prepareTokens(e,a){return e.map((e=>({...e,address:e.wrap?.address||e.address})))}}}});var ae=s(80627),se=s(92221);var te=s(68227),ne=s(65133);const re=(0,t.NY)()({state:{pairs:{},topPairs:{},topTvlPairs:{}},reducers:{setTopPairs(e,a){const{chain:s,pairs:t}=a;return{...e,topPairs:{...e.topPairs,[s.sdId]:t}}},setTopTvlPairs(e,a){const{chain:s,pairs:t}=a;return{...e,topTVLPairs:{...e.topTvlPairs,[s.sdId]:t}}},setPairs(e,a){const{chain:s,pairs:t}=a;return{...e,pairs:{...e.pairs,[s.sdId]:t}}}},effects(e){return{getAddress(a,s){const t=e.token.prepareTokens("tokens"in a?a.tokens:a),{chain:n}="chain"in a?a:s.network;if(!n)return _.je;const[r,i]=e.token.sort(t),o=te[n.sdId][`${r.address}-${i.address}`];if(o)return o;const c=(0,ae.w)(`${r.address}${i.address.slice(2)}`),d=(0,ae.w)(`0xff${n.Factory.address.slice(2)}${c.slice(2)}${n.initCodeHash}`);return(0,se.K)(`0x${d.slice(d.length-40)}`).toLowerCase()},async getTopPairs(a,s){const{pair:t,network:n}=s,{topPairs:r}=t,{chain:i}=n;if(!i)return;const{sdId:o}=i,c=r[o];if(!c){const a=await G.V.fetch(o,"pairs/top-pairs.json").catch((()=>{}));return a&&e.pair.setTopPairs({chain:i,pairs:a}),a}return c},async getTopTvlPairs(a,s){const{pair:t,network:n}=s,{topTvlPairs:r}=t,{chain:i}=n;if(!i)return;const{sdId:o}=i,c=r[o];if(!c){const a=await G.V.fetch(o,"volumes/top-tvl-pairs.json").catch((()=>{}));return a&&e.pair.setTopTvlPairs({chain:i,pairs:a}),a}return c},getDeprecatedPairs(e,a){const{chain:s}=a.network;if(!s)return;const{sdId:t}=s;return ne[t]},getPairFromState(e,a){const{chain:s}=a.network;if(!s)return;const t=a.pair.pairs[s.sdId]?.[e];return t&&t?.timestamp>Date.now()?t:void 0},updatePairState(a,s){const{chain:t}=s.network;if(!t)return;const{address:n}=a;if(n){const r=s.pair.pairs[t.sdId],i={...r,[n]:{...r?.[n],...a,timestamp:Date.now()+3e4}};e.pair.setPairs({chain:t,pairs:i})}},async getPairIG(a,s){const t=e.pair.getAddress(a),{chain:n}=s.network;if(!n)return null;const{sdId:r}=n;return G.V.fetchIG(r,`${t}.json`).then((a=>{const{token0:s,token1:t,chartData:n}=a;return{...a,token0:{...s,icon:e.token.getTokenFromState(s.address)?.icon||Z.x.getNotFoundIcon()},token1:{...t,icon:e.token.getTokenFromState(t.address)?.icon||Z.x.getNotFoundIcon()},chartData:n.map((e=>[1e3*(e.shift()||0),...e]))}})).catch((()=>null))}}}});var ie=s(6665),oe=s(13207);var ce=s(53256),de=s(4687),ue=s(34387),le=s(2755),pe=s(56126),ge=s(81822),me=s(19232);class fe{static lastCallOfBestTrade=0}const he=(0,t.NY)()({state:{mode:oe.YL.EXACT_INPUT,settings:{aggregator:!0},fee:{}},reducers:{setSlippage(e,a){return{...e,settings:{...e.settings,slippage:a}}},setDeadline(e,a){return{...e,settings:{...e.settings,deadline:a}}},setHops(e,a){return{...e,settings:{...e.settings,hops:a}}},setAggregator(e,a){return{...e,settings:{...e.settings,aggregator:a},bestTrade:void 0,fetchingBestTrade:!1}},setSDKPairs(e,a){return{...e,sdkPairs:a}},setBestTrade(e,a){return{...e,bestTrade:a,wrapUnwrapAmount:void 0}},setWrapUnwrapAmount(e,a){return{...e,bestTrade:void 0,wrapUnwrapAmount:a}},setFetchingBestTrade(e,a){return{...e,fetchingBestTrade:a}},setMode(e,a){return{...e,mode:a}},setFee(e,a){const{chain:s,gasPrice:t,timestamp:n}=a;return{...e,fee:{...e.fee,[s.sdId]:{gasPrice:t,timestamp:n}}}}},effects(e){return{async swapWithOdos(a,s){const t=(0,j.D0)().address,{from:n,to:r,onSuccess:i,onError:o}=a,{swap:c}=s,{bestTrade:d}=c;if(!t||!d?.odosPathId||!d.odosAssemble)return;const u=`${n.symbol}-${r.symbol}`,l=`swap-${u}`,p={info:{id:l,title:`Swapping ${u}...`,content:"Check your wallet",duration:1/0},success:{id:l,title:`Swapping ${u} succeeded`},error:{id:l,title:`Swapping ${u} failed`}};e.transactionQueue.rawPush({name:`Swap ${n.symbol} amount for ${r.symbol}`,args:d.odosAssemble.transaction,notifications:p,onSuccess:i,onError:o})},async swapExactIn(a,s){const t=(0,j.D0)().address,{from:n,to:r,onSuccess:i,onError:o}=a,{network:c,swap:d}=s,{settings:u,bestTrade:l}=d;if(!t||!l)return;const{amount:p}=l.amountOut,g=Math.floor(Date.now()/1e3)+60*(u.deadline||_.DF),m=p-(0,pe.Sz)(u.slippage||_.tc,p,r.decimals),f=`${n.symbol}-${r.symbol}`,h=`swap-${f}`,k={info:{id:h,title:`Swapping ${f}...`,content:"Check your wallet",duration:1/0},success:{id:h,title:`Swapping ${f} succeeded`},error:{id:h,title:`Swapping ${f} failed`}},{path:w}=l.routes[0],y=l.amountIn.amount;let v;v=n.wrap?{functionName:"swapExactETHForTokens",args:[m,w,t,g],value:y}:r.wrap?{functionName:"swapExactTokensForETH",args:[y,m,w,t,g]}:{functionName:"swapExactTokensForTokens",args:[y,m,w,t,g]},e.transactionQueue.push({name:`Swap ${n.symbol} amount for ${r.symbol}`,call:{address:c.chain.SmardexRouter.address,abi:de.$,...v},notifications:k,increaseGas:110n,onSuccess:i,onError:o})},async swapExactOut(a,s){const t=(0,j.D0)().address,{from:n,to:r,onSuccess:i,onError:o}=a,{network:c,swap:d}=s,{settings:u,bestTrade:l}=d;if(!t||!l)return;const{amount:p}=l.amountIn,g=Math.floor(Date.now()/1e3)+60*(u.deadline||_.DF),m=p+(0,pe.Sz)(u.slippage||_.tc,p,n.decimals),f=`${n.symbol}-${r.symbol}`,h=`swap-${f}`,k={info:{id:h,title:`Swapping exact ${f}...`,content:"Check your wallet",duration:1/0},success:{id:h,title:`Swapping exact ${f} succeeded`},error:{id:h,title:`Swapping exact ${f} failed`}},{path:w}=l.routes[0],y=l.amountOut.amount;let v;v=n.wrap?{functionName:"swapETHForExactTokens",args:[y,w,t,g],value:m}:r.wrap?{functionName:"swapTokensForExactETH",args:[y,m,w,t,g]}:{functionName:"swapTokensForExactTokens",args:[y,m,w,t,g]},e.transactionQueue.push({name:`Swap exact ${n.symbol} amount for ${r.symbol}`,call:{address:c.chain.SmardexRouter.address,abi:de.$,...v},notifications:k,increaseGas:110n,onSuccess:i,onError:o})},async getBestTrade(a,t){const{swap:{settings:{hops:n=_.Vo,aggregator:r}}}=t,{from:i,to:o,fromAmount:c}=a;e.swap.setFetchingBestTrade(!0),G.V.abortOdos();const[d,u]=await Promise.all([e.token.getPrice(i),e.token.getPrice(o)]),l=e.swap.getThreshold([i.address,o.address]);if(parseFloat((0,z.b)(c,i.decimals))*parseFloat((0,ie.d)(d))>=l&&r){const a=await e.swap.getOdosTrade({from:i,to:o,amount:c});return void(a?"aborted"in a||(e.swap.setFetchingBestTrade(!1),e.swap.setBestTrade({...a,fromNative:!!i.wrap,hasAllowance:!1})):(e.swap.setFetchingBestTrade(!1),e.notificationQueue.push({id:"swap-error",title:"Swap Error",type:"error",content:"Sorry. Something went wrong. Try again later."})))}const p=Date.now();fe.lastCallOfBestTrade=p;const[g,m]=e.token.prepareTokens([i,o]),[f,h]=await Promise.all([e.swap.prepareSDKData({...a,from:g,to:m}),e.swap.getDataToEstimateGas({from:g,to:m})]);if(!f)return void e.swap.setFetchingBestTrade(!1);const{pairs:k,trade:w}=f,y=new Worker(new URL(s.p+s.u(1881),s.b));y.onmessage=a=>{const{data:s}=a,{bestTrade:t}=s;s.timestamp===fe.lastCallOfBestTrade?(e.swap.setFetchingBestTrade(!1),e.swap.setBestTrade({...t,amountInUSD:(0,L.f)((0,z.b)(t.amountIn.amount,g.decimals))*d/_.CI,amountOutUSD:(0,L.f)((0,z.b)(t.amountOut.amount,m.decimals))*u/_.CI,pathViz:e.swap.getPathViz(t),fromNative:!!i.wrap,hasAllowance:!1})):console.debug("Trade cancelled")},y.onerror=a=>{const{message:s}=a;e.notificationQueue.push({id:"swap-error",title:"Swap Error",type:"error",content:s}),e.swap.setFetchingBestTrade(!1),e.swap.setBestTrade(void 0)};const v={pairs:k,trade:w,gasEstimateData:h,params:{maxHops:n>_.Zy?_.Zy:n,maxNumResults:20},timestamp:p};y.postMessage(JSON.stringify(v))},async getFinalBestTrade(a,s){const{network:t,swap:n}=s,{chain:r}=t,{bestTrade:i,sdkPairs:o}=n;if(!r||!i)return!1;const{amountIn:c,amountOut:d}=i,u=e.token.getTokenFromState(c.currency),l=e.token.getTokenFromState(d.currency),{SmardexRouter:p,OdosRouter:g}=r;if(!u||!l)return!1;if(e.swap.setFetchingBestTrade(!0),i?.odosPathId){if(!i.fromNative){if(!g)return e.swap.setFetchingBestTrade(!1),!1;const a=await e.token.getAllowance({token:u,spender:g.address});if(null===a)return e.swap.setFetchingBestTrade(!1),!1;if(c.amount>a)return e.swap.setFetchingBestTrade(!1),e.swap.setBestTrade({...i,hasAllowance:!1}),!0}const a=await e.swap.getOdosTrade({from:u,to:l,amount:c.amount});let s;if(a&&!("aborted"in a)&&a.odosPathId){const t=await e.swap.getOdosAssemble(a.odosPathId).catch((()=>{})),n=t?.simulation.simulationError?.errorMessage?.toLowerCase();if(t?.simulation.isSuccess)return e.swap.setFetchingBestTrade(!1),e.swap.setBestTrade({...a,odosAssemble:t,hasAllowance:!0}),!0;n?.includes("insufficient funds")?s="Sorry. Insufficient funds or gas available to execute transaction.":(n?.includes("slippage")||n?.includes("execution reverted: UniswapV2: K"))&&(s="Sorry. No valid route for this swap; possible low liq/hidden tax. Contact the team if you think it's a mistake.")}return e.notificationQueue.push({id:"swap-error",title:"Swap Error",type:"error",content:s||"Sorry. Something went wrong. Try again later."}),e.swap.setFetchingBestTrade(!1),!1}if(!o)return e.swap.setFetchingBestTrade(!1),!1;const m=i.tradeType===oe.YL.EXACT_INPUT;if(!i.fromNative){const a=await e.token.getAllowance({token:u,spender:p.address});if(null===a)return e.swap.setFetchingBestTrade(!1),!1;const{amount:s}=i.amountIn;if((m?s:s+(0,pe.Sz)(n.settings.slippage||_.tc,s,u.decimals))>a)return e.swap.setFetchingBestTrade(!1),e.swap.setBestTrade({...i,hasAllowance:!1}),!0}const f=[],h=i.routes[0].pairs.map((a=>{const s=e.token.getTokenFromState(a.token0),t=e.token.getTokenFromState(a.token1);if(s&&t){const a=e.pair.getAddress([s,t]),n=(0,j.uN)({address:a,abi:ue.s,chainId:r.id});return f.push(a),Promise.all([n.read.getReserves(),n.read.getFictiveReserves(),n.read.getPriceAverage()])}return null})).filter((e=>null!==e)),k=await Promise.all(h),w=e.swap.getOnChainAmount({addresses:f,pairResults:k});if(w)if(m){const a=await e.token.getPrice(l);i.amountOut=w,i.amountOutUSD=(0,L.f)((0,z.b)(w.amount,l.decimals))*a/_.CI}else{const a=await e.token.getPrice(u);i.amountIn=w,i.amountInUSD=(0,L.f)((0,z.b)(w.amount,u.decimals))*a/_.CI}return e.swap.setFetchingBestTrade(!1),e.swap.setBestTrade({...i,pathViz:e.swap.getPathViz(i),hasAllowance:!0}),!0},getOnChainAmount(e,a){const{bestTrade:s,sdkPairs:t}=a.swap;if(!s||!t)return;const n=s.tradeType===oe.YL.EXACT_INPUT,r=n?e.addresses:e.addresses.reverse(),i=n?e.pairResults:e.pairResults.reverse(),o=[],c=n?Math.round(Date.now()/1e3):void 0;for(let e=0;e<r.length;e+=1){const a=r[e],d=o[e-1],[[u,l],[p,g],[m,f,h]]=i[e],k=t.find((e=>e.address===a)),w=n?ce.YW:ce.FV,{path:y}=s.routes[0];o.push(w(k?.token0||"",k?.token1||"",u,l,p,g,d?.amount||s[n?"amountIn":"amountOut"].amount,y[n?e:y.length-1-e],Number(h),m,f,k?.feesLP||0n,k?.feesPool||0n,c))}return o[o.length-1]},async prepareSDKData(a,s){const{from:t,to:n,fromAmount:r,toAmount:i}=a,{swap:o,token:c,network:d}=s,{mode:u}=o,{tokens:l}=c,{chain:p}=d,g=[],m=await e.pair.getTopPairs(void 0);if(!p||!m)return null;l[p.sdId].filter((e=>e.approved)).forEach((a=>{const s=e.pair.getAddress([t,n]);if(a.address!==t.address){const s=e.pair.getAddress([a,t]);m[a.address]={...m[a.address],[s]:t.address},m[t.address]={...m[t.address],[s]:a.address}}if(m[t.address]={...m[t.address],[s]:n.address},a.address!==n.address){const s=e.pair.getAddress([a,n]);m[a.address]={...m[a.address],[s]:n.address},m[n.address]={...m[n.address],[s]:a.address}}m[n.address]={...m[n.address],[s]:t.address}}));const f=[],h=[];Object.entries(m).forEach((a=>{const s=a[0];Object.keys(a[1]).forEach((t=>{if(h.indexOf(t)<0){const n=e.pair.getPairFromState(t);if(n)console.debug("Fetching pair from state"),g.push(n);else{console.debug("Fetching pair from API");const n=a[1][t],[r,i]=e.token.sortAddresses([s,n]);f.push(G.V.fetchPair(p.sdId,r,i))}h.push(t)}}))}));const k=await Promise.all(f),w=[];k.forEach((e=>{e&&w.push(e.res.json().then((a=>({apiPair:a,token0:e.token0,token1:e.token1}))))}));return(await Promise.all(w)).forEach((a=>{let{apiPair:s,token0:t,token1:n}=a;if(!g.find((e=>e.address===s.p))){const a={address:s.p,token0:t,token1:n,reserve0:BigInt(s.r0),reserve1:BigInt(s.r1),reserve0LastFictive:BigInt(s.r0lf),reserve1LastFictive:BigInt(s.r1lf),priceAverage0:BigInt(s.pa0),priceAverage1:BigInt(s.pa1),feesLP:BigInt(s.flp),feesPool:BigInt(s.fpool),priceAverageLastTimestamp:s.palt};g.push(a),e.pair.updatePairState(a)}})),e.swap.setSDKPairs(g),{pairs:g,trade:{routes:[{pairs:g,path:[t.address,n.address],input:t.address,output:n.address}],amountIn:{currency:t.address,amount:r},amountOut:{currency:n.address,amount:i},tradeType:u}}},async wrapUnwrap(a,s){const t=(0,j.D0)().address,{from:n,to:r,onSuccess:i,onError:o}=a,{network:c,swap:d}=s,{chain:u}=c,{wrapUnwrapAmount:l}=d;if(!u||!t||!l)return;const p=`${n.symbol}-${r.symbol}`;if(n.wrap){const a=`wrap-${p}`,s={info:{id:a,title:`Wrapping ${p}...`,content:"Check your wallet",duration:1/0},success:{id:a,title:`Wrapping ${p} succeeded`},error:{id:a,title:`Wrapping ${p} failed`}};e.transactionQueue.push({name:`Wrap ${n.symbol} amount to ${r.symbol}`,call:{address:n.wrap.address,abi:le.Q,functionName:"deposit",value:l},notifications:s,onSuccess:i,onError:o})}else if(r.wrap){const a=`unwrap-${p}`,s={info:{id:a,title:`Unwrapping ${p}...`,content:"Check your wallet",duration:1/0},success:{id:a,title:`Unwrapping ${p} succeeded`},error:{id:a,title:`Unwrapping ${p} failed`}};e.transactionQueue.push({name:`Unwrap ${n.symbol} amount to ${r.symbol}`,call:{address:r.wrap.address,abi:le.Q,functionName:"withdraw",args:[l]},notifications:s,onSuccess:i,onError:o})}},async getDataToEstimateGas(a,s){const{from:t,to:n}=a,{swap:r,network:i}=s,{chain:o}=i,{mode:c}=r;if(!o)return null;let d;d=c===oe.YL.EXACT_INPUT?t.wrap?"swapExactETHForTokens":n.wrap?"swapExactTokensForETH":"swapExactTokensForTokens":t.wrap?"swapETHForExactTokens":n.wrap?"swapTokensForExactETH":"swapTokensForExactTokens";const u=ge[o.sdId],l=u.hop[d],p=u.nextHop[d],g=e.token.getNativeFromState(void 0);if(!g)return null;const[m,f,h,k]=await Promise.all([e.token.getPrice(g),e.token.getPrice(t),e.token.getPrice(n),e.swap.getGasPrice(void 0)]);return 0n!==m&&0n!==f&&0n!==h&&k?{gasPrice:k,gasQuantitiesFirstHop:l,gasQuantitiesAdditionalHop:p,nativeTokenPrice:m,inputTokenPrice:f,outputTokenPrice:h,nativeTokenDecimals:g.decimals,inputTokenDecimals:t.decimals,outputTokenDecimals:n.decimals}:null},async getGasPrice(a,s){const{network:t,swap:n}=s,{chain:r}=t,{fee:i}=n;if(!r)return null;const{sdId:o,id:c}=r,d=i[o];if(!d||d.timestamp<Date.now()){const a=(0,j.uV)({chainId:c}),s=await a.getGasPrice();return s&&s>0n?(e.swap.setFee({chain:r,gasPrice:s,timestamp:Date.now()+3e4}),s):null}return d.gasPrice},async getOdosTrade(e,a){const{from:s,to:t,amount:n}=e,{swap:r,network:i}=a,{slippage:o}=r.settings,{chain:c}=i,d={chainId:c.id,userAddr:(0,j.D0)().address,inputTokens:[{tokenAddress:s.wrap?_.je:s.address,amount:n}],outputTokens:[{tokenAddress:t.wrap?_.je:t.address,proportion:1}],slippageLimitPercent:o||_.tc,referralCode:364461821,pathViz:!0,disableRFQs:1===c.id};try{const e=await G.V.postOdos("sor/quote/v2",JSON.stringify(d));return e.detail?null:{amountIn:{currency:s.address,amount:n},amountOut:{currency:t.address,amount:BigInt(e.outAmounts[0])},amountInUSD:(0,L.f)(e.inValues[0].toFixed(_.p8)),amountOutUSD:(0,L.f)(e.outValues[0].toFixed(_.p8)),priceImpact:(0,L.f)((e.priceImpact/100).toFixed(_.p8)),percentDiff:(0,L.f)((e.percentDiff/100).toFixed(_.p8)),routes:[],tradeType:oe.YL.EXACT_INPUT,odosPathId:e.pathId,pathViz:e.pathViz}}catch(e){return"AbortError"===e.name?{aborted:!0}:null}},async getOdosAssemble(e,a){return G.V.postOdos("sor/assemble",JSON.stringify({userAddr:(0,j.D0)().address,pathId:e,simulate:!0}))},getPathViz(a,s){const t=[],n=[];return a.routes[0].path.forEach(((a,s,r)=>{const i=e.token.getTokenFromState(a);if(i){t.push({decimals:i.decimals,name:i.name,symbol:i.symbol,visible:!0,width:50});const a=s+1;if(r[a]){const t=e.token.getTokenFromState(r[a]);t&&n.push({edge_len:1,in_value:0,label:"Sentia",nextValue:0,out_value:0,source:s,sourceExtend:!1,sourceToken:{decimals:i.decimals,name:i.name,symbol:i.symbol,asset_id:i.symbol.toLowerCase(),asset_type:"token",is_rebasing:!1,cgid:i.symbol.toLowerCase()},stepValue:0,target:a,targetExtend:!1,targetToken:{decimals:t.decimals,name:t.name,symbol:t.symbol,asset_id:t.symbol.toLowerCase(),asset_type:"token",is_rebasing:!1,cgid:t.symbol.toLowerCase()},value:100})}}})),{nodes:t,links:n}},getThreshold(e,a){const{network:{chain:{sdId:s}}}=a,t=me[s],n=e.join("-"),r=e.reverse().join("-");return t[n]||t[r]||0},abortGetBestTrade(e,a){fe.lastCallOfBestTrade=0,G.V.abortOdos()}}}});var ke=s(84918);const we=(0,t.NY)()({state:{pools:[],settings:{}},reducers:{setPools(e,a){return{...e,pools:a.pools}},setSlippage(e,a){return{...e,settings:{...e.settings,slippage:a}}},setDeadline(e,a){return{...e,settings:{...e.settings,deadline:a}}}},effects:e=>({async getPoolApr(a,s){const{network:t}=s,{chain:n}=t;if(!n)return null;const{sdId:r}=n,[i,o]=e.token.sort(a),c=e.pair.getAddress(a);if(c===_.je)return null;const d=(0,j.uN)({address:c,abi:ue.s,chainId:n.id}),[u,l,p]=await Promise.all([d.read.getReserves().catch((()=>null)),G.V.fetch(r,"volumes/volumes-lp.json").catch((()=>null)),G.V.fetch(r,`pairs/pair-${i.address}-${o.address}.json`).catch((()=>null))]);if(!(u&&l&&l[c]&&p))return null;const g=BigInt(p.flp),m=BigInt(_.p8),f=BigInt(_.D1),h=BigInt(_.NA);return 50n*(BigInt(l[c].volumeToken0_7d)*10n**m*(g*f)/oe.o/u[0]/h+BigInt(l[c].volumeToken1_7d)*10n**m*(g*f)/oe.o/u[1]/h)},async getFarmingApr(a,s){const{price:t,campaign:n,contract:r}=a,{token:i,network:o}=s,{chain:{id:c,sdId:d,SmardexToken:u,timeBetweenBlock:l}}=o,p=BigInt(n.id),g=i.tokens[d].find((e=>e.address===u.address));if(!g)return null;const[m,f,h,k]=await Promise.all([(0,j.uV)({chainId:c}).getBlockNumber(),r.read.campaignInfo([p]),r.read.rewardInfoLen([p]),e.token.getPrice(g)]),w=[];for(let e=0;e<h;e+=1)w.push(r.read.campaignRewardInfo([BigInt(n.id),BigInt(e)]));const y=await Promise.all(w),[,,v,,,T]=f,I=y.map((e=>({endBlock:Number(e[0]),rewardPerBlock:e[1]}))).sort(((e,a)=>e.endBlock>a.endBlock?1:-1)),b=BigInt(Math.floor(86400*_.D1/l));let S=0n;if(m>Number(v)&&0!==I.length&&0n!==t&&0n!==T)for(let e=0;e<I.length;e+=1){const a=I[e];if(m<a.endBlock){S=a.rewardPerBlock*k*_.CI*b*100n/T/t;break}}return S},async getSavedPools(a,s){const t=(0,j.D0)().address,{network:n,farming:r,farmingSponsor:i}=s,{chain:o}=n,{campaigns:c}=r,{campaigns:d}=i;if(!t||!o)return;const{sdId:u}=o;let l=[];const p=K.U.getItem(`pools-${u}-${t}`);p&&(l=JSON.parse(p));const g=await e.pair.getTopTvlPairs(void 0);g&&Object.keys(g).forEach((e=>{if(!l.find((a=>a.address===e))){const{t0:a,t1:s}=g[e];l.push({address:e,token0Address:a,token1Address:s})}}));const m=e.pair.getDeprecatedPairs(void 0);m&&Object.keys(m).forEach((e=>{const a=m[e],[s,t]=e.split("-");l.push({address:a,token0Address:s,token1Address:t,deprecated:!0})}));const f=[],h=[];l.forEach((e=>{const{address:a}=e,s=(0,j.uN)({address:a,abi:ue.s,chainId:o.id});f.push(s.read.balanceOf([t]).catch((()=>null)));const n=c[u].find((e=>e.pairAddress.toLowerCase()===a.toLowerCase()))?.id;if(void 0!==n){const e=(0,j.uN)({address:o.FarmingRange.address,abi:ke.g,chainId:o.id});h.push(e.read.userInfo([BigInt(n),t]))}else{const e=d[u]?.find((e=>e.pairAddress.toLowerCase()===a.toLowerCase()))?.id;if(void 0!==e&&o.FarmingRangeSponsor){const a=(0,j.uN)({address:o.FarmingRangeSponsor.address,abi:ke.g,chainId:o.id});h.push(a.read.userInfo([BigInt(e),t]))}else h.push(Promise.resolve(null))}}));const[k,w]=await Promise.all([Promise.all(f),Promise.all(h)]),y=[];for(let a=0;a<l.length;a+=1){const{address:s,token0Address:t,token1Address:n,deprecated:r}=l[a],i=e.token.getTokenFromState(t),o=e.token.getTokenFromState(n);if(i&&o){const[t,n]=e.token.sort([i,o]),c=k[a]||0n,d=w[a],u={address:s,token0:t,token1:n,balance:c,canBeFarmed:!!d,farmed:!!d&&d[0]>0n,reserve0:0n,reserve1:0n,fictiveReserve0:0n,fictiveReserve1:0n,totalSupply:0n,apr:0n,aprFarming:0n,allowance:0n,price:0n,shares:0n,deprecated:r};y.push(u),e.liquidity.savePool({pool:u})}}e.liquidity.setPools({pools:y})},async getPool(a,s){const{network:t,farming:n,farmingSponsor:r}=s,i=(0,j.D0)().address,{chain:o}=t,{campaigns:c}=n,{campaigns:d}=r;if(!o)return null;const u=e.pair.getAddress(a);if(u===_.je)return null;const{sdId:l}=o,[p,g]=e.token.sort(a),m=(0,j.uN)({address:u,abi:ue.s,chainId:o.id}),f=[m.read.getReserves().catch((()=>null)),m.read.getFictiveReserves().catch((()=>null)),m.read.totalSupply().catch((()=>null))];i&&f.push(m.read.balanceOf([i]).catch((()=>null)),m.read.allowance([i,o.SmardexRouter.address]).catch((()=>null)));let h,k=c[o.sdId].find((e=>e.pairAddress.toLowerCase()===u.toLowerCase()));void 0!==k?h=(0,j.uN)({address:o.FarmingRange.address,abi:ke.g,chainId:o.id}):(k=d[l]?.find((e=>e.pairAddress.toLowerCase()===u.toLowerCase())),void 0!==k&&o.FarmingRangeSponsor&&(h=(0,j.uN)({address:o.FarmingRangeSponsor.address,abi:ke.g,chainId:o.id})));const[w,y,v,T,I]=await Promise.all([Promise.all(f),i&&k&&h?h.read.userInfo([BigInt(k.id),i]):Promise.resolve(null),e.liquidity.getPoolApr(a),e.token.getPrice(p),e.token.getPrice(g)]);if(!w[0]||!w[1]||!w[2])return null;const[b,S]=w[0],[P,$]=w[1],C=w[2],N=w[3]||0n,B=w[4]||0n,A=(b*10n**BigInt(_.p8-p.decimals)*T+S*10n**BigInt(_.p8-g.decimals)*I)/C,F=k&&h?await e.liquidity.getFarmingApr({price:A,campaign:k,contract:h}):null;return{address:u,token0:p,token1:g,reserve0:b,reserve1:S,fictiveReserve0:P,fictiveReserve1:$,totalSupply:C,price:A,balance:N,allowance:B,apr:v,aprFarming:F,shares:N?N*_.CI/C*100n:0n,canBeFarmed:!!k,farmed:!!y&&y[0]>0n}},async getPoolDeprecated(a,s){const{network:t,farming:n,farmingSponsor:r}=s,i=(0,j.D0)().address,{chain:{id:o,sdId:c,SmardexRouterDeprecated:d,FarmingRange:u,FarmingRangeSponsor:l}}=t,{campaigns:p}=n,{campaigns:g}=r,m=e.pair.getDeprecatedPairs(void 0);if(!m||!d)return null;const[f,h]=e.token.sort(a),k=m[`${f.address}-${h.address}`],w=(0,j.uN)({address:k,abi:ue.s,chainId:o}),y=[w.read.getReserves().catch((()=>null)),w.read.getFictiveReserves().catch((()=>null)),w.read.totalSupply().catch((()=>null))];i&&y.push(w.read.balanceOf([i]).catch((()=>null)),w.read.allowance([i,d.address]).catch((()=>null)));let v,T=p[c].find((e=>e.pairAddress.toLowerCase()===k.toLowerCase()));void 0!==T?v=(0,j.uN)({address:u.address,abi:ke.g,chainId:o}):(T=g[c]?.find((e=>e.pairAddress.toLowerCase()===k.toLowerCase())),void 0!==T&&l&&(v=(0,j.uN)({address:l.address,abi:ke.g,chainId:o})));const[I,b,S,P,$]=await Promise.all([Promise.all(y),i&&T&&v?v.read.userInfo([BigInt(T.id),i]):Promise.resolve(null),e.liquidity.getPoolApr(a),e.token.getPrice(f),e.token.getPrice(h)]);if(!I[0]||!I[1]||!I[2])return null;const[C,N]=I[0],B=I[2],A=I[3]||0n,F=I[4]||0n,E=C*10n**BigInt(_.p8-f.decimals)*P,D=N*10n**BigInt(_.p8-h.decimals)*$;return{address:k,token0:f,token1:h,reserve0:C,reserve1:N,totalSupply:B,price:(E+D)/B,balance:A,allowance:F,shares:A?A*_.CI/B*100n:0n,farmed:!!b&&b[0]>0n}},savePool(e,a){const s=(0,j.D0)().address,{pool:t}=e,{chain:n}=a.network;if(!s||!n)return;const r=`pools-${n.sdId}-${s}`,i=K.U.getItem(r),o={address:t.address,token0Address:t.token0.address,token1Address:t.token1.address};if(i){const e=JSON.parse(i);e.find((e=>e.address===o.address))||(e.push(o),K.U.setItem(r,JSON.stringify(e)))}else K.U.setItem(r,JSON.stringify([o]))},async approvePair(a,s){const{pool:t,amount:n,onSuccess:r,onError:i}=a,{address:o,token0:c,token1:d}=t,u=`${c.symbol}-${d.symbol}`,l=`${u} LP`,{chain:p}=s.network;if(!p)return;const g=`approve-liquidity-pair-${u}`,m=!("fictiveReserve0"in t)&&p.SmardexRouterDeprecated?p.SmardexRouterDeprecated.address:p.SmardexRouter.address;await e.transactionQueue.push({name:`Approve ${l} token`,call:{address:o,abi:j.em,functionName:"approve",args:[m,n]},notifications:{info:{id:g,title:`Approving ${l} token...`,content:"Check your wallet",duration:1/0},success:{id:g,title:`Approve of ${l} succeeded`},error:{id:g,title:`Approve of ${l} failed`}},onSuccess:r,onError:i})},async add(a,s){const{address:t}=(0,j.D0)(),{liquidity:n,network:r}=s,{chain:i}=r,{settings:o}=n,{token0:c,token1:d,amount0:u,amount1:l,fictiveReserve0:p,fictiveReserve1:g,onSuccess:m,onError:f}=a;if(!i)return;const h=o.slippage||_.Kq,k=Math.floor(Date.now()/1e3)+60*(o.deadline||_.l$),w=u-(0,pe.Sz)(h,u,c.decimals),y=l-(0,pe.Sz)(h,l,d.decimals),v=`${c.symbol}-${d.symbol}`,T=`add-liquidity-${v}`,I={info:{id:T,title:`Adding liquidity for ${v}...`,content:"Check your wallet",duration:1/0},success:{id:T,title:`Adding liquidity for ${v} succeeded`},error:{id:T,title:`Adding liquidity for ${v} failed`}};let b,S="addLiquidity",P=[{tokenA:c.address,tokenB:d.address,amountADesired:u,amountBDesired:l,amountAMin:w,amountBMin:y,fictiveReserveB:g,fictiveReserveAMin:BigInt(100*(100-h))*p/10000n,fictiveReserveAMax:BigInt(100*(100+h))*p/10000n},t,k];(c.wrap||d.wrap)&&(S="addLiquidityETH",c.wrap?(P=[{token:d.address,amountTokenDesired:l,amountTokenMin:y,amountETHMin:w,fictiveReserveETH:p,fictiveReserveTokenMin:BigInt(100*(100-h))*g/10000n,fictiveReserveTokenMax:BigInt(100*(100+h))*g/10000n},t,k],b=u):(P=[{token:c.address,amountTokenDesired:u,amountTokenMin:w,amountETHMin:y,fictiveReserveETH:g,fictiveReserveTokenMin:BigInt(100*(100-h))*p/10000n,fictiveReserveTokenMax:BigInt(100*(100+h))*p/10000n},t,k],b=l)),await e.transactionQueue.push({name:`Add liquidity for ${v}`,call:{address:i.SmardexRouter.address,abi:de.$,functionName:S,args:P,value:b},notifications:I,onSuccess:m,onError:f})},async remove(a,s){const{address:t}=(0,j.D0)(),{liquidity:n,network:r}=s,{chain:i}=r,{settings:o}=n,{token0:c,token1:d,amount0:u,amount1:l,amountLP:p,nativeOut:g,onSuccess:m,onError:f,deprecated:h}=a;if(!i)return;const k=o.slippage||_.Kq,w=Math.floor(Date.now()/1e3)+60*(o.deadline||_.l$),y=u-(0,pe.Sz)(k,u,c.decimals),v=l-(0,pe.Sz)(k,l,d.decimals),T=`${c.symbol}-${d.symbol}`,I=`remove-liquidity-${T}`,b={info:{id:I,title:`Removing liquidity for ${T}...`,content:"Check your wallet",duration:1/0},success:{id:I,title:`Removing liquidity for ${T} succeeded`},error:{id:I,title:`Removing liquidity for ${T} failed`}};let S="removeLiquidity",P=[c.address,d.address,p,y,v,t,w];(c.hasNative||d.hasNative)&&g&&(S="removeLiquidityETH",P=c.hasNative?[d.address,p,v,y,t,w]:[c.address,p,y,v,t,w]);const $=h&&i.SmardexRouterDeprecated?i.SmardexRouterDeprecated.address:i.SmardexRouter.address;await e.transactionQueue.push({name:`Remove liquidity for ${T}`,call:{address:$,abi:de.$,functionName:S,args:P},notifications:b,onSuccess:m,onError:f})}})});var ye=s(83848),ve=s(27008),Te=s(21318),Ie=s(36200),be=s(21657);function Se(e){const a={},s=e?Te:ve,t=e?be:Ie;return Object.keys(s).forEach((e=>{const n=t[e];a[e]=s[e].map((e=>({...e,token:{...e.token,price:0n},farmingCampaign:n[0],totalStaked:0n,startBlock:0,rewards:[]})))})),{campaigns:a,userCampaigns:{},lastUpdate:{}}}const Pe={setCampaigns(e,a){const{chain:s,campaigns:t}=a,{sdId:n}=s;return{...e,campaigns:{...e.campaigns,[n]:t},lastUpdate:{...e.lastUpdate,[n]:Date.now()}}},setUserCampaigns(e,a){const{chain:s,userCampaigns:t}=a;return{...e,userCampaigns:{...e.userCampaigns,[s.sdId]:t}}},setProcessingTransaction(e,a){return{...e,processingTransaction:a}}};var $e=s(80851);const Ce=(0,t.NY)()({state:Se(),reducers:Pe,effects:e=>({async getCampaigns(a,s){const{staking:t,network:n,token:r}=s,{lastUpdate:i}=t,{chain:o}=n;if(!o)return;const{sdId:c}=o,{FarmingRange:d,Staking:u}=o;if(i[c]&&i[c]>Date.now()-3e4)return void console.debug(`[STAKING:${c}] call getCampaigns from cache`);const l=r.tokens[c].find((e=>e.address===o.SmardexToken.address));if(!l||!u)return;e.staking.resetCampaigns(void 0);const p=(0,j.uN)({address:d.address,abi:ke.g,chainId:o.id}),g=(0,j.uN)({address:u.address,abi:$e.q,chainId:o.id}),[m,f]=await Promise.all([G.V.fetch(c,"volumes/volumes-staking.json").catch((()=>null)),e.token.getPrice(l)]);let h=s.staking.campaigns[c][0];const{farmingCampaign:k}=h,w=BigInt(k.id),y=await p.read.rewardInfoLen([w]),[v,T,I,...b]=await Promise.all([(0,j.uV)({chainId:o.id}).getBlockNumber(),p.read.campaignInfo([w]),g.read.totalShares(),...[...Array(Number(y)).keys()].map((e=>p.read.campaignRewardInfo([w,BigInt(e)])))]);if(!(v&&T&&I&&b))return;const S=await g.read.sharesToTokens([I]);if(S){if(h={...h,totalStaked:S,startBlock:Number(T[2]),rewards:b.map((e=>({endBlock:Number(e[0]),rewardPerBlock:e[1]}))),token:{...h.token,price:f},tvl:f*S/_.CI},v<h.startBlock||0===h.rewards.length||0n===S)h.apr="0",h.apy=0;else{const e=Math.floor(86400*_.D1/Number(o.timeBetweenBlock||12));h.rewards=h.rewards.sort(((e,a)=>e.endBlock>a.endBlock?1:-1));for(let a=0;a<h.rewards.length;a+=1){const s=h.rewards[a];if(v<s.endBlock){h.apr=(0,ie.d)(s.rewardPerBlock*f*BigInt(e)*100n/(h.tvl||1n));break}}const a=(0,L.f)(m?.volumeSDEX_24h||"0")*BigInt(_.D1)/S,s=parseFloat((0,ie.d)(a))+parseFloat(h.apr||"0")/100;h.apy=100*((s/e+1)**e-1)}e.staking.setCampaigns({chain:o,campaigns:[h]})}},async getUserCampaigns(a,s){const{address:t}=(0,j.D0)(),{chain:n}=s.network;if(!n||!t)return;const{SmardexToken:r,Staking:i}=n;if(!i)return;const o=i.address,c=(0,j.uN)({address:o,abi:$e.q,chainId:n.id}),d=(0,j.uN)({address:r.address,abi:q.x,chainId:n.id}),[u]=await c.read.userInfo([t]),[l,p,g]=await Promise.all([c.read.sharesToTokens([u]),d.read.balanceOf([t]),d.read.allowance([t,o])]),m={campaignId:0,shares:u,staked:l,balance:p,allowance:g};e.staking.setUserCampaigns({chain:n,userCampaigns:[m]})},resetCampaigns(a,s){const{chain:t}=s.network;if(!t)return;const[n]=s.staking.campaigns[t.sdId];e.staking.setCampaigns({chain:t,campaigns:[{...n,tvl:void 0,apr:void 0,apy:void 0}]})},resetUserCampaigns(a,s){const{chain:t}=s.network;t&&e.staking.setUserCampaigns({chain:t,userCampaigns:[]})},async approve(a,s){const{campaign:t,amount:n}=a,{symbol:r}=t.token,{chain:i}=s.network,o=`approve-staking-${r}`;if(!i)return;const{Staking:c}=i;c&&(e.staking.setProcessingTransaction(!0),await e.transactionQueue.push({name:`Staking approval of ${r}`,call:{address:t.token.address,abi:j.em,functionName:"approve",args:[c.address,n]},notifications:{info:{id:o,title:`Staking approval of ${r}...`,content:"Check your wallet",duration:1/0},success:{id:o,title:`Staking approval of ${r} succeeded`},error:{id:o,title:`Staking approval of ${r} failed`}},onSuccess:async()=>{await e.staking.getUserCampaigns(void 0),e.staking.setProcessingTransaction(!1)},onError:async()=>{e.staking.setProcessingTransaction(!1)}}))},async deposit(a,s){const{campaign:t,amount:n}=a,{symbol:r}=t.token,{chain:i}=s.network,o=`deposit-staking-${r}`;if(!i)return;const{Staking:c}=i;c&&(e.staking.setProcessingTransaction(!0),await e.transactionQueue.push({name:`Stake of ${r}`,call:{address:c.address,abi:$e.q,functionName:"deposit",args:[n]},notifications:{info:{id:o,title:`Staking of ${r}...`,content:"Check your wallet",duration:1/0},success:{id:o,title:`Stake of ${r} succeeded`},error:{id:o,title:`Stake of ${r} failed`}},increaseGas:110n,onSuccess:async()=>{await e.staking.getCampaigns(void 0),await e.staking.getUserCampaigns(void 0),e.staking.setProcessingTransaction(!1)},onError:async()=>{e.staking.setProcessingTransaction(!1)}}))},async withdraw(a,s){const{address:t}=(0,j.D0)(),{chain:n}=s.network,{campaign:r,shares:i}=a,{symbol:o}=r.token,c=`withdraw-staking-${o}`;if(!n)return;const{Staking:d}=n;d&&(e.staking.setProcessingTransaction(!0),await e.transactionQueue.push({name:`Withdraw of ${o}`,call:{address:d.address,abi:$e.q,functionName:"withdraw",args:[t,i]},notifications:{info:{id:c,title:`Withdrawing of ${o}...`,content:"Check your wallet",duration:1/0},success:{id:c,title:`Withdraw of ${o} succeeded`},error:{id:c,title:`Withdraw of ${o} failed`}},increaseGas:110n,onSuccess:async()=>{await e.staking.getCampaigns(void 0),await e.staking.getUserCampaigns(void 0),e.staking.setProcessingTransaction(!1)},onError:async()=>{e.staking.setProcessingTransaction(!1)}}))}})}),Ne=(0,t.NY)()({state:Se(!0),reducers:Pe,effects:e=>({async getCampaigns(a,s){const{stakingV1:t,network:n,token:r}=s,{lastUpdate:i}=t,{chain:o}=n;if(!o)return;const{sdId:c}=o,{FarmingRangeV1:d,StakingV1:u}=o;if(i[c]&&i[c]>Date.now()-3e4)return void console.debug(`[STAKINGv1:${c}] call getCampaigns from cache`);const l=r.tokens[c].find((e=>e.address===o.SmardexToken.address));if(!l||!d||!u)return;e.stakingV1.resetCampaigns(void 0);const p=(0,j.uN)({address:d.address,abi:ke.g,chainId:o.id}),g=(0,j.uN)({address:u.address,abi:$e.q,chainId:o.id}),m=await e.token.getPrice(l);let f=s.stakingV1.campaigns[c][0];const{farmingCampaign:h}=f,k=BigInt(h.id),[w,y]=await Promise.all([p.read.campaignInfo([k]),g.read.totalShares()]);if(!w||!y)return;const v=await g.read.sharesToTokens([y]);v&&(f={...f,totalStaked:v,token:{...f.token,price:m},tvl:m*v/_.CI},f.apr="0",f.apy=0,e.stakingV1.setCampaigns({chain:o,campaigns:[f]}))},async getUserCampaigns(a,s){const{address:t}=(0,j.D0)(),{chain:n}=s.network;if(!n||!t)return;const{SmardexToken:r,StakingV1:i}=n;if(!i)return;const o=i.address,c=(0,j.uN)({address:o,abi:$e.q,chainId:n.id}),d=(0,j.uN)({address:r.address,abi:q.x,chainId:n.id}),[u]=await c.read.userInfo([t]),[l,p,g]=await Promise.all([c.read.sharesToTokens([u]),d.read.balanceOf([t]),d.read.allowance([t,o])]),m={campaignId:0,shares:u,staked:l,balance:p,allowance:g};e.stakingV1.setUserCampaigns({chain:n,userCampaigns:[m]})},resetCampaigns(a,s){const{chain:t}=s.network;if(!t)return;const[n]=s.stakingV1.campaigns[t.sdId];e.stakingV1.setCampaigns({chain:t,campaigns:[{...n,tvl:void 0,apr:void 0,apy:void 0}]})},resetUserCampaigns(a,s){const{chain:t}=s.network;t&&e.stakingV1.setUserCampaigns({chain:t,userCampaigns:[]})},async approve(a,s){const{campaign:t,amount:n}=a,{symbol:r}=t.token,{chain:i}=s.network,o=`approve-staking-${r}-v1`;if(!i)return;const{StakingV1:c}=i;c&&(e.stakingV1.setProcessingTransaction(!0),await e.transactionQueue.push({name:`Approve stake of ${r}`,call:{address:t.token.address,abi:j.em,functionName:"approve",args:[c.address,n]},notifications:{info:{id:o,title:`Approving stake of ${r}...`,content:"Check your wallet",duration:1/0},success:{id:o,title:`Approve stake of ${r} succeeded`},error:{id:o,title:`Approve stake of ${r} failed`}},onSuccess:async()=>{await e.stakingV1.getUserCampaigns(void 0),e.stakingV1.setProcessingTransaction(!1)},onError:async()=>{e.stakingV1.setProcessingTransaction(!1)}}))},async deposit(a,s){const{campaign:t,amount:n}=a,{symbol:r}=t.token,{chain:i}=s.network,o=`deposit-staking-${r}-v1`;if(!i)return;const{StakingV1:c}=i;c&&(e.stakingV1.setProcessingTransaction(!0),await e.transactionQueue.push({name:`Stake of ${r}`,call:{address:c.address,abi:$e.q,functionName:"deposit",args:[n]},notifications:{info:{id:o,title:`Staking of ${r}...`,content:"Check your wallet",duration:1/0},success:{id:o,title:`Stake of ${r} succeeded`},error:{id:o,title:`Stake of ${r} failed`}},increaseGas:110n,onSuccess:async()=>{await e.stakingV1.getCampaigns(void 0),await e.stakingV1.getUserCampaigns(void 0),e.stakingV1.setProcessingTransaction(!1)},onError:async()=>{e.stakingV1.setProcessingTransaction(!1)}}))},async withdraw(a,s){const{address:t}=(0,j.D0)(),{chain:n}=s.network,{campaign:r,shares:i}=a,{symbol:o}=r.token,c=`withdraw-staking-${o}-v1`;if(!n)return;const{StakingV1:d}=n;d&&(e.stakingV1.setProcessingTransaction(!0),await e.transactionQueue.push({name:`Withdraw of ${o}`,call:{address:d.address,abi:$e.q,functionName:"withdraw",args:[t,i]},notifications:{info:{id:c,title:`Withdrawing of ${o}...`,content:"Check your wallet",duration:1/0},success:{id:c,title:`Withdraw of ${o} succeeded`},error:{id:c,title:`Withdraw of ${o} failed`}},increaseGas:110n,onSuccess:async()=>{await e.stakingV1.getCampaigns(void 0),await e.stakingV1.getUserCampaigns(void 0),e.stakingV1.setProcessingTransaction(!1)},onError:async()=>{e.stakingV1.setProcessingTransaction(!1)}}))}})});const Be=(0,t.NY)()({state:{notifications:[]},reducers:{setNotifications(e,a){return{...e,...a}}},effects(e){return{push(a,s){const{notifications:t}=s.notificationQueue,n=t.findIndex((e=>e.id===a.id)),r=t.slice();n>-1?r.splice(n,1,a):r.push(a),e.notificationQueue.setNotifications({notifications:r})},remove(a,s){const{notifications:t}=s.notificationQueue,n=t.filter((e=>e.id!==a.id));e.notificationQueue.setNotifications({notifications:n})}}}});const Ae=(0,t.NY)()({state:{transactions:[]},reducers:{setTransactions(e,a){return{...e,...a}}},effects(e){return{async push(a,s){const{chain:t}=s.network,{call:n,name:r,notifications:i,increaseGas:o,onSuccess:c,onError:d}=a,{address:u}=(0,j.D0)();i?.info&&e.notificationQueue.push({...i.info});const l=await(0,j.xz)({chainId:t?.id});try{const{request:a}=await(0,j.$q)({...n,walletClient:l});if(o&&n.args){const e=await(0,j.uV)({chainId:t?.id}).estimateContractGas({...n,account:u});e&&(a.gas=(e*o+50n)/100n)}const{hash:p}=await(0,j.n9)(a),g=[...s.transactionQueue.transactions,{hash:p,name:r,status:"pending"}];e.transactionQueue.setTransactions({transactions:g});const m=await(0,j.Mn)({hash:p});"success"===m.status?(i?.success&&e.notificationQueue.push({...i.success,type:"success"}),e.transactionQueue.update({hash:p,status:"success"}),c&&await c(m)):(i?.error&&e.notificationQueue.push({...i.error,type:"error",content:i.error.content||"Please try again. Confirm the transaction and make sure you are paying enough gas!"}),e.transactionQueue.update({hash:p,status:"error"}),d&&await d())}catch(a){i?.error&&e.notificationQueue.push({...i.error,type:"error",content:a.cause?.details||a.shortMessage||"Please try again. Confirm the transaction and make sure you are paying enough gas!"}),console.error(a),d&&await d()}},async rawPush(a,s){const{chain:t}=s.network,{name:n,args:r,notifications:i,onSuccess:o,onError:c}=a;i?.info&&e.notificationQueue.push({...i.info});const d=await(0,j.xz)({chainId:t?.id});try{const a=await(0,j.uw)({...r,walletClient:d,gasPrice:void 0}),{hash:t}=await(0,j.T7)(a),u=[...s.transactionQueue.transactions,{hash:t,name:n,status:"pending"}];e.transactionQueue.setTransactions({transactions:u});const l=await(0,j.Mn)({hash:t});"success"===l.status?(i?.success&&e.notificationQueue.push({...i.success,type:"success"}),e.transactionQueue.update({hash:t,status:"success"}),o&&await o(l)):(i?.error&&e.notificationQueue.push({...i.error,type:"error",content:i.error.content||"Please try again. Confirm the transaction and make sure you are paying enough gas!"}),e.transactionQueue.update({hash:t,status:"error"}),c&&await c())}catch(a){i?.error&&e.notificationQueue.push({...i.error,type:"error",content:a.cause?.details||a.shortMessage||"Please try again. Confirm the transaction and make sure you are paying enough gas!"}),console.error(a),c&&await c()}},update(a,s){const{hash:t,status:n}=a,{transactions:r}=s.transactionQueue,i=r.findIndex((e=>e.hash===t));i<0||(r[i].status=n,e.transactionQueue.setTransactions({transactions:r}))},clear(a,s){e.transactionQueue.setTransactions({transactions:s.transactionQueue.transactions.filter((e=>"pending"===e.status))})}}}});var Fe=s(38166),Ee=s(11514),De=s(47927);const xe=(0,t.NY)()({state:{},reducers:{setCampaign(e,a){const{campaign:s,v1:t}=a;return{...e,[t?"campaignV1":"campaign"]:{...s}}},setProcessingTransaction(e,a){return{...e,processingTransaction:a}}},effects(e){return{async getCampaign(a,s){const{network:t,token:n}=s,{address:r}=(0,j.D0)(),{chain:i}=t;if(!i||!r)return;const{sdId:o}=i,[c,d]=a?[i.FarmingRangeV1,i.StakingV1]:[i.FarmingRange,i.Staking],u=n.tokens[o].find((e=>e.address===i.SmardexToken.address));if(!u||!c||!d)return;const l=(0,j.uN)({address:c.address,abi:ke.g,chainId:i.id}),p=(0,j.uN)({address:d.address,abi:$e.q,chainId:i.id}),g=(0,j.uN)({address:i.SmardexToken.address,abi:q.x,chainId:i.id}),m=a?s.stakingV1.campaigns[o][0]:s.staking.campaigns[o][0],{farmingCampaign:f}=m,h=BigInt(f.id),[k]=await p.read.userInfo([r]),[w,y,v,T,I,b]=await Promise.all([l.read.campaignInfo([h]),p.read.totalShares(),p.read.sharesToTokens([k]),g.read.balanceOf([r]),g.read.allowance([r,d.address]),e.token.getPrice(u)]);if(!w||!y)return;const S=await p.read.sharesToTokens([y]);if(!S)return;const P={...m,totalStaked:S,token:{...m.token,price:b},tvl:b*S/_.CI,shares:k,staked:v,balance:T,allowance:I};m.apr="0",m.apy=0,e.stakingMigration.setCampaign({campaign:P,v1:a})},async withdraw(a,s){const{address:t}=(0,j.D0)(),{chain:n}=s.network,{campaign:r,amount:i,onSuccess:o}=a,{symbol:c}=r.token,d=`withdraw-staking-${c}-v1`;if(!n)return;const{StakingV1:u}=n;if(!u)return;const l=(0,j.uN)({address:u.address,abi:$e.q,chainId:n.id});e.stakingMigration.setProcessingTransaction(!0);const p=await l.read.tokensToShares([i]);await e.transactionQueue.push({name:`Withdraw of ${c}`,call:{address:u.address,abi:$e.q,functionName:"withdraw",args:[t,p]},notifications:{info:{id:d,title:`Withdrawing of ${c}...`,content:"Check your wallet",duration:1/0},success:{id:d,title:`Withdraw of ${c} succeeded`},error:{id:d,title:`Withdraw of ${c} failed`}},increaseGas:110n,onSuccess:async()=>{await e.stakingMigration.getCampaign(!0),e.stakingMigration.setProcessingTransaction(!1),await o()},onError:async()=>{e.stakingMigration.setProcessingTransaction(!1)}})},async approve(a,s){const{campaign:t,amount:n,onSuccess:r}=a,{symbol:i}=t.token,{chain:o}=s.network,c=`approve-staking-migration-${i}`;if(!o)return;const{Staking:d}=o;d&&(e.stakingMigration.setProcessingTransaction(!0),await e.transactionQueue.push({name:`Staking approval of ${i}`,call:{address:t.token.address,abi:j.em,functionName:"approve",args:[d.address,n]},notifications:{info:{id:c,title:`Staking approval of ${i}...`,content:"Check your wallet",duration:1/0},success:{id:c,title:`Staking approval of ${i} succeeded`},error:{id:c,title:`Staking approval of ${i} failed`}},onSuccess:async()=>{await e.stakingMigration.getCampaign(!1),e.stakingMigration.setProcessingTransaction(!1),await r()},onError:async()=>{e.stakingMigration.setProcessingTransaction(!1)}}))},async deposit(a,s){const{campaign:t,amount:n,onSuccess:r}=a,{symbol:i}=t.token,{chain:o}=s.network,c=`deposit-staking-${i}`;if(!o)return;const{Staking:d}=o;d&&(e.stakingMigration.setProcessingTransaction(!0),await e.transactionQueue.push({name:`Stake of ${i}`,call:{address:d.address,abi:$e.q,functionName:"deposit",args:[n]},notifications:{info:{id:c,title:`Staking of ${i}...`,content:"Check your wallet",duration:1/0},success:{id:c,title:`Stake of ${i} succeeded`},error:{id:c,title:`Stake of ${i} failed`}},increaseGas:110n,onSuccess:async()=>{await e.stakingMigration.getCampaign(!1),e.stakingMigration.setProcessingTransaction(!1),await r()},onError:async()=>{e.stakingMigration.setProcessingTransaction(!1)}}))}}}});var Ve=s(84296),Re=s(16645),Oe=s(94500);const Ue={network:Q,metrics:W,token:ee,pair:re,swap:he,liquidity:we,farming:ye.ZO,farmingV1:ye.jK,farmingSponsor:ye.zg,staking:Ce,stakingV1:Ne,notificationQueue:Be,transactionQueue:Ae,comparator:Fe.P,historicExplorer:Ee.M,farmingMigration:De.H,stakingMigration:xe,bridge:Ve.o,communityRewards:Re.B,farmingTop:Oe.f},Me=(0,t.S1)({models:Ue})},14646:function(e,a,s){s.d(a,{D:function(){return i},m:function(){return r}});var t=s(61673),n=s(27296);const r=20;function i(){const e={},a={},s={price:0n,balance:0n,allowance:0n};Object.keys(n).forEach((r=>{e[r]=n[r].map((e=>({...e,...s,approved:!0}))),a[r]=e[r].filter((e=>e.popular));const i=t.U.getItem(`tokens-${r}`);if(i){JSON.parse(i).forEach((a=>{e[r].unshift({...a,...s,approved:!1})}))}}));const r=t.U.getItem("token-lists");let i;return i=r?JSON.parse(r):{CoinGecko:!0,"1inch":!0,Aave:!0},{tokens:e,popularTokens:a,sources:i}}}}]);