"use strict";(self.webpackChunksmardex_web=self.webpackChunksmardex_web||[]).push([[5434],{10596:function(t,n,e){e.d(n,{A:function(){return p},b:function(){return h}});var r=e(72356),o=e(93064),s=e(12400),a=e(90652),i=e(54739),l=e(5182),u=e(22459);const c=Buffer.from([21,31,124,117]);var h;function g(t,n,e){if(null!=e&&t===e)return 0;const r=null==e?0:1;for(let e=0;e<n.length;e++)if(t===n[e])return e+r;return n.push(t),n.length-1+r}!function(t){t[t.BUILDING=0]="BUILDING",t[t.BUILT=1]="BUILT",t[t.SIGNED=2]="SIGNED",t[t.SUBMITTED=3]="SUBMITTED",t[t.COMMITTED=4]="COMMITTED"}(h||(h={}));class p{constructor(){this.status=h.BUILDING,this.transactions=[],this.methodCalls=new Map,this.signedTxns=[],this.txIDs=[]}getStatus(){return this.status}count(){return this.transactions.length}clone(){const t=new p;return t.transactions=this.transactions.map((({txn:t,signer:n})=>({txn:o.Transaction.from_obj_for_encoding({...t.get_obj_for_encoding(),grp:void 0}),signer:n}))),t.methodCalls=new Map(this.methodCalls),t}addTransaction(t){if(this.status!==h.BUILDING)throw new Error("Cannot add transactions when composer status is not BUILDING");if(this.transactions.length===p.MAX_GROUP_SIZE)throw new Error(`Adding an additional transaction exceeds the maximum atomic group size of ${p.MAX_GROUP_SIZE}`);if(t.txn.group&&t.txn.group.some((t=>0!==t)))throw new Error("Cannot add a transaction with nonzero group ID");this.transactions.push(t)}addMethodCall({appID:t,method:n,methodArgs:e,sender:o,suggestedParams:a,onComplete:i,approvalProgram:c,clearProgram:d,numGlobalInts:f,numGlobalByteSlices:m,numLocalInts:w,numLocalByteSlices:I,extraPages:E,boxes:x,note:b,lease:T,rekeyTo:G,signer:D}){if(this.status!==h.BUILDING)throw new Error("Cannot add transactions when composer status is not BUILDING");if(this.transactions.length+n.txnCount()>p.MAX_GROUP_SIZE)throw new Error(`Adding additional transactions exceeds the maximum atomic group size of ${p.MAX_GROUP_SIZE}`);if(0===t){if(null==c||null==d||null==f||null==m||null==w||null==I)throw new Error("One of the following required parameters for application creation is missing: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices")}else if(i===u.hq.UpdateApplicationOC){if(null==c||null==d)throw new Error("One of the following required parameters for OnApplicationComplete.UpdateApplicationOC is missing: approvalProgram, clearProgram");if(null!=f||null!=m||null!=w||null!=I||null!=E)throw new Error("One of the following application creation parameters were set on a non-creation call: numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages")}else if(null!=c||null!=d||null!=f||null!=m||null!=w||null!=I||null!=E)throw new Error("One of the following application creation parameters were set on a non-creation call: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");if(null==e&&(e=[]),e.length!==n.args.length)throw new Error(`Incorrect number of method arguments. Expected ${n.args.length}, got ${e.length}`);let S=[],y=[];const U=[],B=[],M=[],A=new Map,C=x||[];for(let t=0;t<e.length;t++){let o=n.args[t].type;const s=e[t];if((0,r.AE)(o)){if(!(0,l.Xw)(s)||!(0,r.vJ)(o,s.txn))throw new Error(`Expected ${o} transaction for argument at index ${t}`);if(s.txn.group&&s.txn.group.some((t=>0!==t)))throw new Error("Cannot add a transaction with nonzero group ID");U.push(s)}else{if((0,l.Xw)(s))throw new Error(`Expected non-transaction value for argument at index ${t}`);if((0,r.o5)(o)&&(A.set(B.length,S.length),B.push(o),M.push(s),o=new r.Pu(8)),"string"==typeof o)throw new Error(`Unknown ABI type: ${o}`);S.push(o),y.push(s)}}const P=[],_=[],L=[],N=[];for(let n=0;n<B.length;n++){const e=B[n],s=M[n];let a=0;switch(e){case r.UV.account:{const t=new r.JQ;a=g(t.decode(t.encode(s)),_,o);break}case r.UV.application:{const n=new r.Pu(64),e=n.decode(n.encode(s));if(e>Number.MAX_SAFE_INTEGER)throw new Error(`Expected safe integer for application value, got ${e}`);a=g(Number(e),L,t);break}case r.UV.asset:{const t=new r.Pu(64),n=t.decode(t.encode(s));if(n>Number.MAX_SAFE_INTEGER)throw new Error(`Expected safe integer for asset value, got ${n}`);a=g(Number(n),N);break}default:throw new Error(`Unknown reference type: ${e}`)}P.push(a)}for(let t=0;t<P.length;t++){y[A.get(t)]=P[t]}if(S.length>15){const t=S.slice(14),n=y.slice(14);S=S.slice(0,14),y=y.slice(0,14),S.push(new r.w1(t)),y.push(n)}const O=[n.getSelector()];for(let t=0;t<S.length;t++)O.push(S[t].encode(y[t]));const v={txn:(0,s.makeApplicationCallTxnFromObject)({from:o,appIndex:t,appArgs:O,accounts:_,foreignApps:L,foreignAssets:N,boxes:C,onComplete:null==i?u.hq.NoOpOC:i,approvalProgram:c,clearProgram:d,numGlobalInts:f,numGlobalByteSlices:m,numLocalInts:w,numLocalByteSlices:I,extraPages:E,lease:T,note:b,rekeyTo:G,suggestedParams:a}),signer:D};this.transactions.push(...U,v),this.methodCalls.set(this.transactions.length-1,n)}buildGroup(){if(this.status===h.BUILDING){if(0===this.transactions.length)throw new Error("Cannot build a group with 0 transactions");this.transactions.length>1&&(0,a.assignGroupID)(this.transactions.map((t=>t.txn))),this.status=h.BUILT}return this.transactions}async gatherSignatures(){if(this.status>=h.SIGNED)return this.signedTxns;const t=this.buildGroup(),n=t.map((t=>t.txn)),e=new Map;for(let n=0;n<t.length;n++){const{signer:r}=t[n];e.has(r)||e.set(r,[]),e.get(r).push(n)}const r=Array.from(e),s=await Promise.all(r.map((([t,e])=>t(n,e)))),a=t.map((()=>null));for(let t=0;t<r.length;t++){const n=r[t][1],e=s[t];for(let t=0;t<n.length;t++)a[n[t]]=e[t]}if(!a.every((t=>null!=t)))throw new Error(`Missing signatures. Got ${a}`);const i=a.map(((t,n)=>{try{return(0,o.decodeSignedTransaction)(t).txn.txID()}catch(t){throw new Error(`Cannot decode signed transaction at index ${n}. ${t}`)}}));return this.signedTxns=a,this.txIDs=i,this.status=h.SIGNED,a}async submit(t){if(this.status>h.SUBMITTED)throw new Error("Transaction group cannot be resubmitted");const n=await this.gatherSignatures();return await t.sendRawTransaction(n).do(),this.status=h.SUBMITTED,this.txIDs}async execute(t,n){if(this.status===h.COMMITTED)throw new Error("Transaction group has already been executed successfully");const e=await this.submit(t);this.status=h.SUBMITTED;const r=this.transactions.findIndex(((t,n)=>this.methodCalls.has(n))),o=-1===r?0:r,s=await(0,i.K)(t,e[o],n);this.status=h.COMMITTED;const a=s["confirmed-round"],l=[];for(const[n,o]of this.methodCalls){const a=e[n],i={txID:a,rawReturnValue:new Uint8Array,method:o};try{const e=n===r?s:await t.pendingTransactionInformation(a).do();if(i.txInfo=e,"void"!==o.returns.type){const t=e.logs||[];if(0===t.length)throw new Error("App call transaction did not log a return value");const n=Buffer.from(t[t.length-1],"base64");if(n.byteLength<4||!n.slice(0,4).equals(c))throw new Error("App call transaction did not log a return value");i.rawReturnValue=new Uint8Array(n.slice(4)),i.returnValue=o.returns.type.decode(i.rawReturnValue)}}catch(t){i.decodeError=t}l.push(i)}return{confirmedRound:a,txIDs:e,methodResults:l}}}p.MAX_GROUP_SIZE=16},87970:function(t,n,e){e.d(n,{HN:function(){return a},_:function(){return s},rD:function(){return o}});const r=1e6,o="Microalgos should be positive and less than 2^53 - 1.";function s(t){if(t<0||!Number.isSafeInteger(t))throw new Error(o);return t/r}function a(t){const n=t*r;return Math.round(n)}}}]);